<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<link rel="stylesheet" href="../style.css">
</head>
<body>
	<h1>Промисы</h1>
	<h2>C курсов GLO</h2>
	<p><strong>Создание promise</strong></p>
	<img src="prim6.jpg" alt="">
	<p>Конструктор Promise принимает в качестве аргумента callBack функцию, которую еще называют <b>executer</b>, эта функция принимает два аргумента (которые являются функциями): <b>resolve</b> - выполнится в случае успешного выполнения Promise. И <b>reject</b> - выполнится в случае ошибки.</p>
	<h3>Пример функции которая возвращает promise</h3>
	<img src="prim7.jpg" alt="">
	<h3>Методы Promise</h3>
	<p><b>all</b> - этот метод принимает в качестве аргумента массив промисов, и метод then выполнится только тогда, когда все промисы будут выполнены.</p>
	<img src="prim8.jpg" alt="">
	<p><b>race</b> - этот метод так же принимает массив промисов и в метод then попадет тот промис который авполнится первым</p>
	<img src="prim9.jpg" alt="">


















	<h2>Владилен</h2>
	<p>Для понятия работы Promise сэмулируем запрос на сервер</p>
	<p>Рассмотрим код:</p>
	<img src="prim1.jpg" alt="">
	<p>Сначала мы выводим в консоли надпись: "Request data..."</p>
	<p>Затем запускаем функцию setTimeout и на вход даем стрелочную функцию которая будет выводить в консоль надпись "Preparing data...", а так же произойдет создание объекта <b>backendData</b> c несколькими ключами (свойствами). Все это будет выполнено через две секунды.</p>
	<p>Затем будет выполнен второй вложенный setTimeout который добавляетнашему обьекту еще одно свойство <b>modifate</b> со значением true. После, в консоль выводится надпись "Data received" и так же выводится наш объект Это будет выполнено так же через две секунды.</p>
	<p>Это классический пример ассинхронного кода с callback функциями. Т.е. нам необходимо что бы последующий код запускался только после того как будет исполнен предыдущий. Но что если таких шагов нам требуется много. Получится огромная вложенность функций, такая вложенность называется адовая пирамида. Что бы такого не получалось, придумали <b>Промисы</b>.</p>
	<p>Рассмотрим пример:</p>
	<img src="prim2.jpg" alt="">
	<p>Мы создали новую переменную <b>p</b>. Прородителем переменной является класс <b>Promise</b>. На вход промису даем стрелочную функцию с двумя параметрами: <b>resolve</b> и <b>reject</b>. Это две функции которые всегда должны быть у промиса. Первая функция (resolve) вызывается когда асинхронный код внутри промиса выполняется успешно, вторая же (reject) вызывается когда асинхронный код внутри промиса выполнился с ошибкой.</p>
	<p>Далее внутрь нашего промиса мы помещаем ассинхронный код (в нашем примере это setTimeout), который выводит в консоль надпись и создает наш объект с ключами.</p>
	<p>Там же (в ассинхронном коде - в setTimeout) мы вызываем метод <b>resolve</b>, тем самым мы говорим что наш ассинхронный код выполнен, и который будет возвращать что-то. В нашем примере это будет наш объект <b>backendData</b></p>
	<h2>then</h2>
	<p>Теперь как нам обеспечить бесконечную строгую последовательность выполнения кода (последующий ассинхронный код выполнится только после выполнения предыдущего)</p>
	<p>Рассмотрим код:</p>
	<img src="prim3.jpg" alt="">
	<p>После того как мы объявили переменную с типом <b>Promise</b> и поместили в него ассинхронный код, после этого мы обращаемся к нашей переменной и вызываем у нее метод <b>then</b> (затем). т.е что будет после того как промис выполнился. Методу <b>then</b> мы даем на вход стрелочную функцию, которой в свою очередь даем на вход какой-то контекст. То что в предыдущем промисе было возвращено методом <b>resolve</b> то и попадет в качестве входа этой функции.</p>
	<p>Далее наша функция должна нам вернуть новый промис, у которого так же два метода resolve и reject и внутрь которого будет помещен ассинхронный код. и в котором мы так же должны вызвать метод <b>resolve</b>, указывая тем самым что код выполнен и что бы что то дать на выход</p>
	<p>После метода <b>then</b> мы можем прописать еще один <b>then</b>, код которого будет выполнен только после того как выполнится код первого <b>then</b>. И так до бесконечности. в итоге у нас последовательный ассинхронный код без вложенности и адских пирамид.</p>
	<h2>catch</h2>
	<p>В промисах помимо <b>then</b> есть и другие методы. В случае какой-то ошибки, если промис не выполнился или выполнился с ошибкой, мы будем попадать в метод <b>catch</b></p>
	<p>рассмотрим код:</p>
	<img src="prim4.jpg" alt="">
	<p>т.е. методу <b>catch</b> на вход даем стрелочную функцию. У этой функции на вход попадает какая-то ошибка (err - объект вызвавший ошибку) и далее мы выводим ее в консоль. Метод catch лучше прописывать в конце цепи промисов.</p>
	<h2>finally</h2>
	<p>Еслит метод then выполняется только в случае успешного выполнения промиса, а метод catch d случае ошибки, то метод <b>finally</b> выполнится в любом случае</p>
	<img src="prim5.jpg" alt="">



	<script>

		


		const getPromise = (data) => {
			return new Promise((resolve, reject) => {
				if (true){
					resolve(data);
				} else {
					reject('error');
				}
			}) 
		}

		Promise.race([getPromise('JavaScript'), getPromise('CSS'), getPromise('React')])
			.then(data => console.log(data))
		






	</script>
</body>
</html>