<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Элементы DOM</h1>

    <h2>Подключение к элементу</h2>
    <p>Подключение осуществляется с помощью методов</p>
    
        <p><b>querySelector()</b> - в качестве входного параметра указывается селектор элемента. Возвращает объект (элемент)</p>
        <p><b>querySelectorAll()</b> - в качестве входного параметра указывается селектор элементов. Возвращает коллекцию объектов (псевдомассив)</p>
<p>Примеры:</p>
<img src="./prim1.jpg" alt="">
<h2>Манипуляция со стилями элементов</h2>
<p>Для того что бы получить доступ к стилям элемента, мы обращаемся к нему и применяем метод <b>style</b>, далее ставим точку и указываем то свойство которое нам нужно.</p>
<p><b>ВАЖНО</b> - в JS нельзя в именах использовать тире, поэтому в указаниях свойства CSS надо использовать принцип camelCase</p>
<p>Пример</p>
<img src="./prim2.jpg" alt="">
<p><b>getComputedStyle()</b> - метод который возвращает объект со всеми стилями элемента. Метод принимает один обязательный аргумент и второе не обязательный. Первый - это элемент стили которого надо получить. Второй - псевдоэлемент (after, before) стили которого нужно посмотреть</p>
<h2>Содержимое элемента</h2>
<p>Для получения содержимого этомента, т.е. до того что заключено в теге можно получить используя два метода</p>
<p><b>innerHTML</b> - позволяет добавлять шаблонные строки</p>
<p><b>textContent</b> - получает текст заключенный в тег</p>
<img src="./prim3.jpg" alt="">
<img src="./prim4.jpg" alt="">
<h2>Манипуляция со свойствами элементом</h2>
<p>Обращаемся к элементу, через точку прописываем его свойство и далее что хотим с ним, то и делаем</p>
<img src="./prim5.jpg" alt="">
<h2>ClassList</h2>
<p>C помощью метода <b>classList</b> мы можем манипулировать классами элемента:</p>
<p><b>add</b> - добавить класс</p>
<p><b>remove</b> - удалить класс</p>
<p><b>contain</b> - проверить наличие (вернется либо false либо true)</p>
<p><b>toggle</b> - если класс есть то он удалится, если его нет то добавится</p>

<h2>Data атрибуты</h2>
<p>Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.</p>
<p>Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.</p>
<img src="./prim6.jpg" alt="">
<p>Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами, записанными с помощью верблюжьей нотации: dataset.orderState</p>
<p><b>Методы для работы с атрибутами:</b></p>
<p><b>elem.hasAttribute(name)</b> – проверить на наличие.</p>
<p><b>elem.getAttribute(name)</b> – получить значение.</p>
<p><b>elem.setAttribute(name, value)</b> – установить значение.</p>
<p><b>elem.removeAttribute(name)</b> – удалить атрибут</p>
<p><b>elem.attributes</b> – это коллекция всех атрибутов</p>

<h2>Объект Document</h2>
<p><b>Объект document</b> и его элементы являются объектами <b>Node</b>. Класс Node имеет следующие свойства:</p>
<ul>
    <li><b>parentNode</b> - возвращает родительский элемент</li>
    <li><b>childNodes</b> - возвращает дочерний элемент</li>
    <li><b>firstChild, lastChild</b> - возвращают первый и последний дочерний элемент</li>
    <li><b>nextSibling, previousSibling</b> - возвращают следующий и предыдущий братский элемент (Братские элементы имеют одного и того же родителя)</li>
    <li><b>nodeValue</b> - возвращает текстовое содержимое элемента</li>
    <li><b>nodeName</b> - возвращает имя тега элемента</li>
    <li><b>documentElement</b> - возвращает элемент, который является коренным элементом документа document (например элемент html).</li>
</ul>
<p>Существует так же свойство <b>children</b> которое возвращает массив дочерних ЭЛЕМЕНТОВ, не Node узлов, а именно элементов. Что бы обратиться к определенному элементу можно указать индекс элемента: wrapper.children[0]</p>
<p><b>parentElement</b> - возвращает родительский документ, не Node а именно элемент</p>

<h2>Создание узлов</h2>
<p>Для создания элемента используется метод <b>createElement()</b>. Этому методу в качестве аргумента необходимо задать имя тега.</p>
<img src="./prim7.jpg" alt="">

<h2>Вставка узлов</h2>
<p><b>Метод append()</b> - вызывается относительно узла элемента, в который нужно вставить новый узел. Новый узел будет помещен в конец родительского элемента.</p>
<img src="./prim8.jpg" alt="">
<p>Метод append перемещает элемент, если элемент до этого был размещен в другом месте то он оттуда будет удален и вставлен в новое место.</p>
<p><b>Метод prepend()</b> - делает тоже самое что и append только вставляет елемент в начало родителя</p>
<p><b>Метод before()</b> - делает тоже самое что и append только вставляет елемент в перед родителем</p>
<p><b>Метод after()</b> - делает тоже самое что и append только вставляет елемент после родителя</p>
<p><b>Метод replaceWith()</b> - заменяет элемент относительно которого был вызван метод на элемент который был передан в качестве аргумента</p>
<img src="./prim13.jpg" alt="">



<h3>Element.insertAdjacent...</h3>
<p><b>insertAdjacentElement()</b> - добавляет переданный элемент в DOM-дерево относительно элемента, вызвавшего метод Принимает два аргумента: position и element.</p>
<ul>
    <li><b>beforebegin</b> -  до самого element (до открывающего тега).</li>
    <li><b>afterbegin</b> -  сразу после открывающего тега  element (перед первым потомком).</li>
    <li><b>beforeend</b> - сразу перед закрывающим тегом element (после последнего потомка).</li>
    <li><b>afterend</b> - после element (после закрывающего тега).</li>
</ul>
<img src="./prim10.jpg" alt="">
<p><b>insertAdjacentHTML()</b> - разбирает указанный текст как HTML или XML и вставляет полученные узлы (nodes) в DOM дерево в указанную позицию. Данная функция не переписывает имеющиеся элементы, что предотвращает дополнительную сериализацию и поэтому работает быстрее, чем манипуляции с innerHTML. Принимает два аргумента: position и text. Position те же что и у insertAdjacentElement</p>
<img src="./prim11.jpg" alt="">
<p><b>insertAdjacentText()</b> - помещает заданный текстовый узел в указанную позицию относительно элемента, который передан в вызове метода. Принимает два аргумента: position и text. Position те же что и у insertAdjacentElement</p>
<p><b>remove()</b> - метод удаляет из DOM элемент</p>
<img src="./prim12.jpg" alt="">
<p>Важно добавить что из псевдомассива элемент не будет удален, только из DOM дерева</p>

<h2>Клонирование элемента</h2>
<p>Что бы склонировать элемент используется метод <b>cloneNode()</b></p>
<img src="./prim14.jpg" alt="">
<p>Если не указать входным параметром методу - true то он выполнит поверхностное клонирование, т.е. не скопирует все содержимое элемента (текст, вложенные элементы и т.д.). Вот как выглядит полная копия</p>
<img src="./prim15.jpg" alt="">



<h2>Удаление и замена узлов узлов</h2>
<p><b>Метод removeChild()</b> - удаляет элемент из дерева документов. Метод вызывается относительно родительского элемента, а в качестве аргумента принимает дочерний элемент, который необходимо удалить</p>
<p><b>Метод replaceChild()</b> - удаляет один дочерний элемент и замещает его другим. Метод вызывается относительно родительского элемента, а в качестве аргументов принимает: 1 - новый элемент, 2 - старый элемент.</p>
<h2>Координаты документа и видимой области</h2>
<p>Существует две точки которые мы можем считать началом координат:</p>
<ul>
    <li>Относительно верхнего левого узла видимой области</li>
    <li>Относительно верхнего левого узла документа</li>
</ul>
<h3 class="test">Свойства:</h3>
<ul>
    <li><b>pageXOffset</b> - свойство объекта window отображающее фактические координаты по оси X</li>
    <li><b>pageYOffset</b> - свойство объекта window отображающее фактические координаты по оси Y</li>
    
    <img src="prim10.jpg" alt="">

    <li><b>scrollLeft</b> - тоже самое что и pageXOffset но для элемента DOM, а не для window</li>
    <li><b>scrollTop</b> - тоже самое что и pageYOffset но для элемента DOM, а не для window</li>

    <img src="prim11.jpg" alt="">
    <li><b>innerHeight</b> - Высота (в пикселях) области просмотра окна браузера, включая, если отображается, горизонтальную полосу прокрутки</li>
    <li><b>innerWidth</b> - Только для чтения свойство innerWidth возвращает внутреннюю ширину окна в пикселях</li>


</ul>
<h2>Определение геометрии элемента</h2>
<p>Самый простой способ определить размеры и координаты элемента - обратиться к его методу <b>getBoundingClientRect()</b>. Он возвращает объект со свойствами left, right, top и bottom. Позиция элемента указывается в системе координат видимой области т.е. все свойства, кроме width и height, являются относительными к верхнему левому углу viewport-а.. Этот метод возвращает свойства только блочного элемента. Что бы получить свойства строчного элемента используется метод <b>getClientRects()</b>.</p>
<p>Объекты возвращаемые методами getBoundingClientRect и getClientRects хрянят статические сведения о визуальном представлении элемента на момент вызова, они не обновляются и доступны только для чтения.</p>
<p>Что бы определить элемент в указанной точке, можно использовать метод <b>elementFromPoint()</b>. Он принимает координаты X и Y относительно начала координат видимой области и возвращает самый внутренний и самый верхний (в смысли атрибута z-index) элемент. Если передать координаты точки за пределами видимой области, метод вернут null</p>
<h2>Прокрутка</h2>
<p>Что бы заставить браузер прокрутить документ можно использовать метод <b>scrollTo()</b> объекта window. В качестве аргументов метод принимает координаты X и Y. Так же в качестве аргумента можно передать объект:</p>
<img src="prim9.jpg" alt="">
<p>Свойство <b>behavior</b> определяет как будет прокручиваться документ. <b>smooth</b> - плавная прокрутка</p>
<h2>Получение размеров и позиции элемента</h2>
<h3 class="test">Свойства:</h3>
<ul>
    <li><b>offsetWidth</b> - ширина элемента</li>
    <li><b>offsetHeight</b> - высота элемента</li>
    <li><b>offsetLeft</b> - координат по оси X</li>
    <li><b>offsetTop</b> - координат по оси Y</li>
    <li><b>offsetParent</b> - определяет относительно кого идет отчет координат</li>
    <li><b>clientWidth</b> - ширина элемента</li>
    <li><b>clientHeight</b> - высота элемента</li>
    <li><b>clientLeft</b> - координат по оси X</li>
    <li><b>clientTop</b> - координат по оси Y</li>
</ul>
<p>clientWidth отличается от offsetWidth тем, что в ширине не учитывается ширина рамки</p>
<p>clientLeft и clientTop возвращают растояние от внешней границы до внутренней границы, по сути это ширина рамки</p>
<h2>Получение выделенного текста</h2>
<p><b>Метод window.getSelection()</b> - возвращает объект Selection описывающий текущий выделенный текст.</p>
<p>Oбъект Selection имеет метод <b>toString</b> который возвращает простое текстовое содержание выделенной области.</p>
<h2>Редактирование содержимого</h2>
<p>Для редактирования содержимого можно в теге содержащий текст установить атрибут <b>contenteditable</b>. После этого текст внутри этого тега можно редактировать. Когда пользователь кликнет по содержимому тега, появится курсор и можно будет вводить текст с клавиатуры.</p>
<p>так же можно прописать такой код:</p>
<p><b>document.body.contentEditable = true</b></p>
<p>И весь документ будет доступен для редактирования.</p>



<div class="parent"></div>




    <script src="main.js"></script>
</body>
</html>