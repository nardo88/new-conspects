<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="stylesheet" href="../style.css">
</head>
<body>
	<h1>Объекты</h1>
<p>Для объявления объекта можно использовать два синтаксиса:</p>
<img src="book1.jpg">
<p>Второй способ называется <b>Литерным</b>. В этом случае мы сразу можем задать свойства для объекта</p>
<p>Для обращения к свойствам объекта, сначала вызывают объект, затем через точку указывают свойство</p>
<img src="book2.jpg">
<p>Так же обращаться к свойствам объекта можно вот так:</p>
<img src="book2.1.jpg">

<p>Для удаления свойства можно использовать опратор <b>delete</b></p>
<img src="book3.jpg">
<h2>Проверка существования свойств</h2>
<p><b>С помощью оператора in</b></p>
<img src="book4.jpg" alt="">
<p>он возвращает true если объект имеет собственное или унаследованное свойство с этим именем. имя свойства обязательно указываем в кавычках</p>
<p><b>С помощью метода hasOwnProperty()</b></p>
<img src="book2.2.jpg">
<p>метод <b>hasOwnProperty</b> проверяет имеет ли объект собственное свойство с указанным именем. Для наследуемых свойств он возвращает false</p>
<p><b>С помощью метода propertyIsEnumerable()</b></p>
<img src="book2.3.jpg">
<p>этот метод возвращает true только если собственное свойство объекта имеет дескриптор <b>enumerable</b> в значении true</p>

<h2>Цикл for...in</h2>
<p>Этот цикл используется для перебора всех свойств объекта</p>
<p>Синтаксис:</p>
<img src="book5.jpg" alt="">
<p>Пример</p>
<img src="book6.jpg" alt="">
<p>что бы получить значения ключей объекта этот же цикл уже будет выглядеть вот так:</p>
<img src="prim12.jpg">











<h2>Создание объекта с помощью функции-конструктора (оператор new)</h2>
<p><span class="red">ВАЖНО</span> В этом способе нельзя использовать стрелочные функции</p>
<p>В функциях конструктора есть два правила:</p>
<ul>
	<li>1. Имя функции должно называться с заглавной буквы (иначе ошибка)</li>
	<li>2. Функция-конструктор должна вызываться при помощи оператора <b>new</b></li>
</ul>
<p>Создадим функцию которая нам будет создавать объект</p>
<img src="book7.jpg" alt="">
<p>Что бы задать метод склассу которы создан с помощью функции конструктора обращаемся к его свойству <b>prototype</b> и в него добавляем метод</p>
<img src="prim19.jpg" alt="">
<h3>Наследование</h3>
<p>Что бы наследовать свойства и методы родительского класса, в конструкторе дочернего класса указываем Название родительского класса, затем используем метод <b>apply</b> b в качестве аргумента указываем this и массив arguments</p>
<img src="prim20.jpg" alt="">










<h2>Создание объектов с помощью Object.create. (getters, setters)</h2>
<p>Пример</p>
<img src="prim8.jpg">
<p>Метод <b>create</b> получает на вход два параметра, которые оба являются объектами. Первый параметр может содержать объект который станет прототипом для нового объекта. Во втором мы указываем ключи объекта (свойства) и так же можем указать методы объекта.</p>
<p>В примере свойство которое мы задали нашему объекту <b>person</b> - это его имя (name). Это свойство может иметь собственные свойства (дескрипторы):</p>
<ul>
	<li><b>value</b> - значение</li>
	<li><b>enumirable</b> - перечисляемость (по умолчанию значение true, т.е. это свойство будет видно для итерации, цикла for...in</li>
	<li><b>writeble</b> - это свойство отвечает за то, можем ли мы редактировать наше свойство. по умолчанию этот ключ имеет значение true</li>
	<li><b>configurable</b> - это свойство отвечает за то, можем ли мы далить свойство. по умолчанию так же стоит true</li>
</ul>
<p>Что бы <b>получить</b> дескрипторы свойств нужно воспользоваться методом глобального объекта <b>Object</b> - <b>getOwnPropertyDescriptor()</b>. У этого метода два входных параметра:</p>
<p><b>1 - </b>объект</p>
<p><b>2 - </b>свойство объекта у которого нужно посмотреть дескрипторы</p>
<img src="book2.4.jpg">
<p>Что бы <b>изменить</b> дескрипторы используется метод <b>defineProperty</b></p>
<p>Этому методу мы передаем уже три входных параметра:</p>
<p><b>1 - </b>объект</p>
<p><b>2 - </b>свойство объекта у которого нужно поменять дескрипторы</p>
<p><b>3 - </b>объект с дескрипторами свойства</p>
<img src="book2.5.jpg">
<h2>Артибуты объектов</h2>
<p><span class="atr">prototype</span> - определяет объект от которого наследуются свойства</p>
<p>Как посмотреть прототип объекта:</p>
<img src="book2.6.jpg">
<p>Еще один способ</p>
<img src="book2.7.jpg">
<p><span class="atr">class</span> - содержит строку с информацией о типе объекта</p>
<p><span class="atr">extensible</span> - определяет допускается ли добавлять в объект новые свойства т.е. является ли объект расширяемым.</p>
<p>Что бы проверить этот атрибут используется метод глобального объекта:</p>
<img src="book2.8.jpg">
<p>Возвращает булевое значение.</p>
<p>Что бы сделать объект не срасширяемым используется метод <b>preventExtensions</b></p>
<img src="book2.9.jpg">
<p>После того как мы сделали объект не расширяемым, его нельзя будет сделать обратно расширяемым</p>
<h2>getters, setters</h2>
<p>Рассмотрим пример</p>
<img src="prim9.jpg">
<p>Ключу (свойству) <b>age</b> мы задали методы get и set. Метод get возвращает какое либо значение. В то время когда метод set принимает како-либо значение (value)</p>
<p>Так при запросе в консоли person.age мы получим следующий результат:</p>
<img src="prim10.jpg" alt="">
<p>Т.е. сработает метод <b>get</b></p>
<p>Но если мы обратимся к person.age и зададим какой-нибудь параметр, то сработает метод <b>set</b> </p>
<img src="prim11.jpg">
<p>В итоге, свойству объекта мы можем задать метод get - который будет что то возвращать, или метод get - который будет что то получать и обрабатывать это</p>
<h2>Копирование объектов</h2>
<p>Допустим у нас есть объект</p>
<img src="prim13.jpg">
<p>В данном примере переменная <b>person</b> не содержит внутри себя объект, а лишь хранить в себе ссылку до этого объекта. Если мыс оздадим вторую переменную и поместим в нее первую</p>
<img src="prim14.jpg">
<p>То это совершенно не значит что у нас теперь два объекта, у нас две переменные, которые ссылаются на один и тот же объект. Теперь если мы обратимся ко второй переменной и изменим у объекта значение свойства country </p>
<img src="prim15.jpg">
<p>То мы поменяем значение у объекта, а не у переменной. Т.е. если вывести в консоль значение ключа <b>country</b> у person, то получим вот такой результат</p>
<img src="prim16.jpg">
<p>Мы не имеем два объекта, мы имеем лишь две ссылки до одного и того же объекта.</p>
<p>Но что нам делать если нам нужно именно сделать копию объекта? Для этого нам нужно использовать оператор <b>spread</b>. Вот как это будет выглядеть:</p>
<img src="prim17.jpg">
<p>Теперь если обратиться к person2 и поменять значение примитивного ключа country, то оно поменяется только у person2. Но! Это касается только примитивных значений (строка, число или булевое значение). Если в качестве ключа у нас имеется объект или массив (не примитивный тип), то что бы получить копию этого свойства (а не ссылку), нужно будет каждое такое свойство копировать с помощью spread</p>
<img src="prim18.jpg">

<h3>Второй способ</h3>
<p>метод <b>assign</b> принимает два аргумента, 1 - целевой объект 2 - объект прототип</p>
<img src="prim21.jpg">
<p>Так же <b>assign</b> можно использовать для объединения двух объектов в один</p>
<img src="prim22.jpg">

<script>

	// 1 вариант
	const obj = {
		name: 'max'
	}
	const objClone = Object.assign({}, obj)

	// 2 вариант
	let newObj = {}
	Object.assign(newObj, obj)
	console.log(newObj);



	const obj1 = {
		name: 'Max'
	}
	const obj2 = {
		age: 32
	}
	const objAll = Object.assign({}, obj1, obj2)

	console.log(objAll);

</script>

</body>
</html>
