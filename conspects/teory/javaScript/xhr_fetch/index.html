<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>

	<h1>XHR, Fetch</h1>
	<ul class="nav">
		<li><a class="nav__link" href="#xhr_vlad">XHR Владилен</a></li>
		<li><a class="nav__link" href="#fetch_vlad">Fetch Владилен</a></li>
		<li><a class="nav__link" href="#xhr_book">XHR Учебник</a></li>
		<li><a class="nav__link" href="#fetch_glo">fetch GLO</a></li>
	</ul>
	<h1  id="xhr_vlad">XHR Владилен</h1>
	<p>С помощью методов <b>Fetch</b> и <b>Fetch</b> мы можем взаимодействовать с сервером через ассинхронные запросы. Для лучшего понимания как все это работает, рассмотрим сначала метод <b>XHR</b></p>
	<h2>Подготовка URL</h2>
	<p>Перед тем как мы начнем, первое что нужно сделать, это подготовить URL адрес, по которому мы сможем делать ассинхронные запросы.</p>
	<p>Существует такой сервис, который называется <a style="outline: none; text-decoration: none;" href="https://jsonplaceholder.typicode.com/" target="_blank"><b>JSONPlaceholder</b></a> </p>
	<p>Что это за сервис? Это Фэйк-онлайн REST API для тестирования и прототипирования</p>
	<p>На этом сервисе есть ссылка, которая будет нам возвращать JSON строку с массивом объектов, которые будут содержать данные 10-ти пользователей. Вот эта ссылка:</p>
	<p><a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a></p>
	<h2>XHR</h2>
	<p>B так, копируем это адрес и помещаем для удобства в переменную <b>requestURL</b></p>
	<img src="prim1.jpg" alt="">
	<p>Теперь нам надо создать переменную, которая будет экземпляром глобального класса <b>XMLHttpRequest</b></p>
	<img src="prim2.jpg" alt="">
	<p>Применяя к этой переменной определенные методы, мы будем совершать запросы на сервер в фоновом режиме, не перезагружая страницу.</p>
	<p>Первый метод, который мы применим называется <b>open</b></p>
	<img src="prim3.jpg" alt="">
	<p>Этот метод открывает соединение и имеет два входных параметра:</p>
	<ul>
		<li><b>1. Метод</b> - по которому мы будем делать запрос</li>
		<li><b>2. URL</b> - адрес куда будем соединяться</li>
	</ul>	
	<p>Что за методы? Существуют базовые методы, такие как GET или POST. которые нам известны из php</p>
	<ul>
		<li><b>'GET'</b> - этот метод вызывается, когда нам надо получить данные с сервера</li>
		<li><b>'POST'</b> - Этот метод вызывается, когда мы отправляем какие-либо данные на сервер, например заполнив форму и нажав кнопку SUBMIT</li>
		<li><b>'DELETE'</b> - этот метод используется когда нам надо удалить данные</li>
		<li><b>'PUT'</b> - этот метод используется когда нам надо обновить данные на сервере.</li>
	</ul>
	<p>Выбирая метод мы, тем самым говорим, что именно надо сделать</p>
	<p>Второй метод который мы применм к xhr выглядит вот так:</p>
	<img src="prim4.jpg" alt="">
	<p>Этот метод отправляет запрос на сервер</p>
	<p>Теперь если в браузере открыть панель разработчика (f12) и перейти на вкладку "Network" и нажать на кнопку фильтра XHR, то мы увидим строку users с типом xhr</p>
	<img src="prim5.jpg" alt="">
	<p>Нажимаем на это строчку, после чего откроются данные запроса</p>
	<p><b>Вкладка Headers</b> - здесь хранится информация по запросу. По какому URL был сделан запрос, статус запроса, IP сервера и т.д.</p>
	<p><b>Вкладка Response</b> - Здесь мы видим реальный ответ сервера на запрос.</p>
	<p><b>Вкладка Preview</b> - тут мы видим ответ сервера, но уже после того как Chrome нам ответ распарсил. В нашем случае это массив объектов</p>
	<p>Для того что бы мы могли обрабатывать те данные, которые прислал нам сервер, нам надо к нашей переменной xhr применить метод <b>onload</b></p>
	<p>Очень важно этот метод вызывать до метода <b>send</b>/ выглядеть это будет вот так:</p>
	<img src="prim6.jpg" alt="">
	<p>Методу onload мы на вход даем стрелочную функцию, которая будет выводить в консоль результат запроса, т.е. response (англ - ответ). Но результат что вернул нам сервер в формате JSON, т.е. в виде строки, нам надо его распарсить. Длеается это так:</p>
	<img src="prim7.jpg" alt="">
	<p>Теперь в консоли мы увидим массив объектов с данными пользователей</p>
	<p>Но лучше вопрос с переводом из JSON в массив решить иначе, ведь при таком методе нам придется каждый раз вызывать метод parse.</p>
	<p>У класса XHR есть еще один метод, который переводит любые ответы сервера из JSON в массив.</p>
	<img src="prim8.jpg" alt="">
	<h2>Как обрабатывать ошибки?</h2>
	<p>У объекта xhr есть еще один очень полезный метод - <b>onerror</b></p>
	<img src="prim9.jpg" alt="">
	<p><b>onerror</b> - возвращает текст и код ошибки если в response что-то не так</p>
	<p>onerror помещается перед методом send</p>
	<p>Бывают случаи когда например сервер нам отвечает без ошибки, но при этом он несет в себе статус-код, который говорит нам о том, что произошла ошибка. При этом мы не будем попадать в <b>onerror</b>, потому что это другого типа ошибки, Network ошибки и т.д. Для того что бы более универсально обрабатывать все потенциальные ошибки, мы можем обратиться к методу <b>onload</b> b использовать там условный оператор if</p>
	<img src="prim10.jpg" alt="">
	<p>xhr.status - возвращает статус ответа сервера. самый известный 404 (not found)</p>
	<h2>Оборачиваем теперь все это в функцию</h2>
	<p>Сделаем теперь наш метод универсальным, запихаем весь код в функцию, которая нам будет возвращать Promise, ведь код обращения к серверу является ассинхронным.</p>
	<p>Создадим функцию <b>sendRequest</b></p>
	<img src="prim11.jpg" alt="">
	<p>Функция <b>sendRequest</b> принимает в себя два параметра: метод и url, которые используюся в методе <b>xhr.open(method, url)</b></p>
	<p>Далее наша функция возвращается нам новый промис, у которого естественно два метода: resolve и reject.</p>
	<p>Затем создаем переменную xhr, применяем к ней сначала метод <b>open</b>, затем указываем тип ответа на запрос - json, далее идет код отлова ошибок. Здесь важно заметить, что результаты ошибок и результаты успешного выполнения запроса, мы помещаем не в консоль, а даем на вход методам промиса resolve и reject. В заключении вы вызываем метод <b>send</b></p>
	<p>После того как наша функция готова, вызываем ее. можно повесить ее на нажатие кнопки или еще как...</p>
	<img src="prim12.jpg" alt="">
	<p>Т.к. sendRequest возвращает нам промис, а методe resolve мы дали на вход результат запроса (response), то мы можем к нашей функции применить метод <b>then</b> с параметром data. То что нам вернет resolve то и попадет в data метода then. Этот результат мы выводим в консоль. Вот как выглядит вызов функции</p>
	<img src="prim13.jpg" alt="">
	<p>Этот способ написания кода называется "чейнить" (от англ chain - цепь)</p>
	<h2>Метод 'POST'</h2>
	<p>Теперь преобразуем нашу функцию на отправку данных на сервер, т.е. мы будем у метода open использовать метод 'POST'</p>
	<p>Так как нам надо что то отправлять, добавим еще один входной параметр нашей функции sendRequest. По умолчанию этот параметро будет null, так как при вызове метода 'GET', там ничего не должно быть</p>
	<p>Этот третий параметр будет принимать в себя объект. Для начала создадим этот объект</p>
	<img src="prim14.jpg" alt="">
	<p>Теперь этот входной параметр надо передать методу xhr.send. Но дело в том, что перед этим нам надо наш объект перевести в JSON строку, поэтому код будет выглядеть так:</p>
	<img src="prim15.jpg" alt="">
	<p>Но этого не достаточно! Нам так же необходимо перевести в JSON headers request, т.е. установить header который отправляется с запросами. Делается это так:</p>
	<img src="prim16.jpg" alt="">
	<p>Эта запись прописывается рядом с xhr.responseType = 'json'</p>
	<p>Теперь наша функция выглядит вот так:</p>
	<img src="prim17.jpg" alt="">
	<p>А вызов функции с методом 'POST' Выглядит так:</p>
	<img src="prim18.jpg" alt="">
	<br><br>
	<h2 id="fetch_vlad">Fetch 'GET'</h2>
	<p>Как будет выглядеть наша функция <b>sendRequest</b> но уже с применением метода <b>fetch</b>? Тут все еще проще и лаконичнее</p>
	<p>Метод fetch нам сразу будет возвращать promise. Метод принимает в себя два параметра. Первым параметром идет url. Вот как это выглядит:</p>
	<img src="prim19.jpg" alt="">
	<p>В принципе этого кода нам достаточно, что бы выполнить метод 'GET'.</p>
	<p>Учитывая то,что метод fetch нам возвращает Promise, то мы можем его зачейнить методом then. но мы пока этого делать не будем и посмотрим в браузере, что нам выдал метод fetch в консоль на этом этапе:</p>
	<p>Вызвали мы нашу функцию вот так:</p>
	<img src="prim20.jpg" alt="">
	<p>А вот что вышло в консоли</p>
	<img src="prim21.jpg" alt="">
	<p>Вместо массива объектов, мы получили объект который содержит данные о б ответе сервера (Response). У этого объекта есть ключ, который называется body и именно в нем хранятся нужные нам данные. но пока они в формате <b>ReadableStream</b></p>
	<p>Этот формат был создан для оптимизации, в случае если мы получаем с сервера большой объем данных, то мы их будем получать поэтапно.</p>
	<p>Как нам перевести из <b>ReadableStream</b> в наш привычный массив объектов? Очень просто. Мы к методу ftch применяфем метод then.</p>
	<img src="prim22.jpg" alt="">
	<p>Метод then получает на вход метод с входным параметром <b>response</b> и этот метод возвращает нам результат метода text() который мы применили к response.</p>
	<p>Теперь если посмотретьв  консоль то мы увидим ту самую строку JSON с данными пользователей</p>
	<img src="prim23.jpg" alt="">
	<p>Теперь этот результат надо распарсить. Для этого у fetch есть метод JSON, т.е. вместо метода text() мы используем метод json()</p>
	<img src="prim24.jpg" alt="">
	<p>Теперь если обновить страницу, то в консоли мы увидим уже знакомый нам массив объектов</p>
	<img src="prim25.jpg" alt="">
	<br>
	<h2 >Fetch 'POST'</h2>
	<p>Теперь разберемся с методом 'POST'. Как было сказано выше, метод Fetch принимает в себя два параметра, первый это url, а второй - это объект</p>
	<p>Этот объект должен иметь три ключа:</p>
	<ul>
		<li><b>method</b> - который мы получаем из входного параметра нашей функции (GET, POST)</li>
		<li><b>body</b> - то что будет отправляться на сервер методом POST Его так же берем из входного параметра нашей функции. И кстати этот параметр так же надо будет оборачивать в JSON строку.</li>
		<li><b>headers</b>- как и в xhr нам необходимо параметр Content-type перевести в JSON. Для удобства мы создадим объект headers и в нем будем перечислять все необходимые header и их переводы в JSON</li>
	</ul>
	<p>Вот как теперь выглядит наша функция:</p>
	<img src="prim26.jpg" alt="">
	<p>Вызов нашей функции с методом POST выглядит как и раньше</p>
	<img src="prim18.jpg" alt="">
	<h2>Как обрабатывать ошибки?</h2>
	<p>Просто добавляем if</p>
	<img src="prim27.jpg" alt="">
	<h1 id="xhr_book">XMLHttpRequest (из учебника JavaScript. Подробное руководство, 6-е издание)</h1>
	<h2><span class="number">1</span> Создание экземпляра класса XMLHttpRequest</h2>

	<p class="code">const xhr = new XMLHttpRequest()</p>

	<p>Запрос состоит из 4-ех частей:</p>
	<ol>
		<li>Метод</li>
		<li>URL адрес</li>
		<li>Заголовок запроса (необязательный параметр)</li>
		<li> Тело запроса (необязательный параметр)</li>
	</ol>
	<p>Ответ состоит из 3-ех частей:</p>
	<ol>
		<li>Код состояния запроса</li>
		<li>Набор заголовков ответа</li>
		<li>Тело ответа</li>
	</ol>
	<h2><span class="number">2</span> Выполнение запроса</h2>
	<p>После того как объект <b>XHR</b> был создан, следующий этап - это определение параметров запроса. Осуществляется это методом <b>open()</b> e которого есть два обязательных аргумента:</p>
	<ol>
		<li>Метод</li>
		<li>URL адрес</li>
	</ol>
	<p class="code">xhr.open("GET", "data.php")</p>
	<ul>Методы:
		<li><b>GET</b> - используются для обычных запросов</li>
		<li><b>POST</b> - Обычно используются для отправки данных с HTML-форм</li>
	</ul>
	<p>Второй аргумент - это URL адрес</p>
	<p>При выполнении запроса к ресурсу защищенному паролем, можно передать методу open 4-ым и 5-ым аргументом логин и пароль</p>
	<h2><span class="number">3</span> Установка заголовка</h2>
	<p>Запрос <b>POST</b> требует наличие заголовка (пробовал без него все работает)</p>
	<p>Заголовок создается с помощью метода <b>setRequestHeader()</b></p>
	<p>В качетсве аргументов принимается:</p>
	<ol>
		<li>Имя заголовка</li>
		<li>Тип данных</li>
	</ol>
	<p class="code">xhr.setRequestHeader('Content-Type', 'text/plan')</p>
	<p>Нельзя придумывать свои заголовки</p>
	<h2><span class="number">4</span> Передача тела запроса</h2>
	<p>Последний этап в запросе - передача необязательного теля и отправка его серверу. Делается это с помощью метода <b>send()</b></p>
	<p class="code">xhr.send()</p>
	<p>GET запрос не имеет тела, в этом случае можно передать null или вообще опустить аргумент</p>
	<p class="attention">метод setRequestHeader() должен вызываться после метода open() и перед методом send()</p>
	<h2><span class="number">5</span> Получение ответа</h2>
	<p>Полный ответ содержит:</p>
	<ol>
		<li>Код состояния</li>
		<li>Заголовок</li>
		<li>Тело ответа</li>
	</ol>
	<p>Все это доступно в виде свойств и методов объекта XMLHttpRequest</p>
	<ul>
		<li>свойство <b>status</b> и <b>statusText</b> возвращают код состояния в числовом виде и в текстовом виде</li>
		<li>Заголовки можно получить с помощью метода <b>getResponseHeader()</b></li>
		<li>Тело ответа доступно через свойства <b>responseText</b>, <b>responseXML</b> или просто <b>response</b> (последний самый удобный он не зависит от типа данных)</li>
	</ul>
	<h2><span class="number">5</span> Свойство readyState</h2>
	<p>Это целочисленное значение, определяющее код состояние. Его возможные значения:</p>
	<div class="grid">
		<div class="grid__item">Константа</div>
		<div class="grid__item">Значение</div>
		<div class="grid__item">Смысл</div>
		<div class="grid__item">UNSENT</div>
		<div class="grid__item">0</div>
		<div class="grid__item">Метод open() еще не был вызван</div>
		<div class="grid__item">OPENED</div>
		<div class="grid__item">1</div>
		<div class="grid__item">Метод open() был вызван</div>
		<div class="grid__item">HEADERS_RECEIVED</div>
		<div class="grid__item">2</div>
		<div class="grid__item">Были получены заголовки</div>
		<div class="grid__item">LOADING</div>
		<div class="grid__item">3</div>
		<div class="grid__item">Идет прием тела ответа</div>
		<div class="grid__item">DONE</div>
		<div class="grid__item">4</div>
		<div class="grid__item">Приме ответа завершен</div>
	</div>
	<h2><span class="number">6</span> Событие readystatechange</h2>
	<p>Это событие генерируется каждый раз когда изменяется значение свойства <b>readyState</b></p>
	<p>пример функции получения ответа</p>
	<img src="prim28.jpg" alt="">
	<h2><span class="number">7</span> Получение синхронного ответа</h2>
	<p>Что бы получить синхронный ответ, нужно методу <b>open</b> передать в качестве третьего аргумента - false и тогда метод send() будет заблокирован до завершения запроса.</p>
	<p>пример</p>
	<img src="prim29.jpg" alt="">
	<h2><span class="number">8</span> Запрос с данными HTML-формы</h2>
	<p>Как правило, дефолтное поведение формы на событие submit отключается. Все значения input помещаются в объект, объект переводится в формат JSON и это все подается в качестве аргумена передается методу send()</p>
	<p>На стороне сервера php код обрабатывает все отправленное с помощью метода POST</p>
	<h2><span class="number">9</span> События возникающие в ходе выполнения запроса</h2>
	<p><b>loadstart</b> - возникает один раз при вызове метода send</p>
	<p><b>progress</b> - возникает каждые 50 милисекунд в ходе загрузки. можно использовать для обратной связи.</p>
	<p><b>load</b> - по завершении запроса возбуждается событие load. В load мы должны проверять код состояния в объекте xhr (свойство status)</p>
	<p><b>timeout</b> - возбуждается если предельное время ожидания ответа превышено</p>
	<p><b>abort</b> - возбуждается если выполнение запроса было прервано</p>
	<p><b>error</b> - возникает при неудачном соединении или других ошибок сети</p>
	<p><b>loadend</b> - срабатывает когда запрос завершен</p>
	<h3>Свойства объекта события</h3>
	<p><b>loaded</b> - количество байтов переданных на момент события</p>
	<p><b>total</b> - общий объем загружаемых данных</p>
	<h2><span class="number">10</span> События в ходе выгрузки</h2>
	<p>У XHR есть свойство upload - это объект имеющий методы - события. Что бы посмотреть все методы - события выводим в консоль:</p>
	<p class="code">xhr.upload</p>
	<p>Будет выведен список методов - событий с помощью которых мы будем мониторить ход выгрузки.</p>
	<h2><span class="number">11</span> Прерывание запросов</h2>
	<p>Выполнение HTTP-запроса можно прерывать вызовом метода <b>abort()</b>. Вызов этого метода генерирует событие <b>abort</b>. Основная причина для прерывания запроса - это превышение предельного времени ожидания.</p>
	<h2><span class="number">12</span> Предельное время ожидания</h2>
	<p>Свойство <b>timeout</b> можно поместить значение - промежуток времени в милисекундах, после которого запрос автоматически будет прерван. По истечении этого времени будет сгенерировано событие <b>timeout</b></p>
	<h1  id="fetch_glo">fetch GLO</h1>
	<h2><span class="number">1</span> как ловить ошибки</h2>
	<img src="prim30.jpg" alt="">
	<h2><span class="number">2</span> Методы обработки ответов</h2>
	<ul>
		<li><b>response.text()</b> - метод вернет строку в том формате в котором она пришла
		<br>
		<br>
		<img src="prim31.jpg" alt="">

		</li>
		<li><b>response.json()</b> - вернет распарсеный JSON т.е. объект</li>
		<li><b>response.block()</b> - необходим для обработки полученных файлов</li>
	</ul>
	<h2><span class="number">3</span> Второй аргумент fetch</h2>
	<p>Вторым аргументом fetch принимает объект с настройками</p>
	<ul>
		<li><b>method</b> - метод запроса (GET POST)</li>
		<li><b>mode</b> - режим ограничения домена. По умолчанию стоит same-origin т.е. запросы работают в одном домене, остальные запросы будут отклонены. Режим <b>cors</b> позволяет делать запросы на сторонние api</li>
		<li><b>cash</b> - режим кеширования, по умолчанию - default</li>
		<li><b>credentials</b> - можно ли передавать учетные данные вместе с запросом. <b>include</b> - разрешается, <b>same-origin</b> - можно только в совем домене. Это же свойство отвечает за куки (можно ли зашивать в куки идентификатор)</li>
		<li><b>headers</b> - заголовки. Это объект, т.е. заголовки передаются в таком формате <br><br>
		<img src="prim32.jpg" alt="">
		
		</li>
		<li><b>redirect</b> - как действовать при редиректе. <b>follow</b> - позволяет переадресовывать наш запрос, <b>error</b> - мы будем прерывать перенаправление</li>
		<li><b>referrer</b> - позволяет указывать откуда пришел запрос</li>
		<li><b>body</b> - тело запроса, данные которые улетат с POST запросом</li>
	</ul>
	







	<script src="script.js"></script>
</body>
</html>