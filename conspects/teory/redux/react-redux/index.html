<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <h1>React-Redux</h1>
    <p>Для установки этой библиотеки в терминале вводим команду:</p>
    <span class="code">npm install react-redux --save</span>
    <p>Для чего нужна эта библиотека? Он играет роль посредника между UI и BLL (тоже самое что и  контейнерная компонента, более того <b>react-redux</b> создает контейнерную компоненту с помощью метода <b>connect</b>)</p>
    <h2>Создание контекста</h2>
    <p>Создание контекста с помощью <b>react-redux</b> ничем не отличается от создания обычного контекста. Все что нам нужно это обернуть в тег <b>Provider</b> компонент <b>App</b> и создать оболочке атрибут <b>store</b> и передать в него наш store</p>
    <img src="prim1.jpg" alt="">
    <h2>Connect</h2>
    <p>Для создания контейнерной компоненты мы будем использовать метод библиотеки react-redux <b>connect</b></p>
    <p>Создаем отдельный файл. Перед использованием этого метода не забываем импортировать эту функцию</p>
    <img src="prim2.jpg" alt="">
    <p>Создаем контейнерную компоненту. </p>
    <img src="prim3.jpg" alt="">
    <p>О чем говорят два вызова () ()? Это значит что функция connect при первом вызове нам возвращает функцию. А вторым вызовом мы это функцию вызываем. В качестве аргумента второму вызову нам нужно передать компоненту, для которой наша компонента будет контейнером</p>
    <img src="prim4.jpg" alt="">
    <p>Теперь надо нашей презентационной компоненте (в нашем примере это - Dialogs) передать пропсы и callback</p>
    <p>Для этого создадим две вспомогательные функции, которые должны возвращать по одному объекту</p>
    <img src="prim5.jpg" alt="">
    <p>Как вообще работает функцию <b>connect</b>? Он асоздает контейнерную компоненту, внутри этой контейнерной компоненты будет рендерится презентационная компонента, которая передана во втором вызове функции. Этой же презентационной компоненте будут переданы пропсы которые нам вернет функция f1 и колбеки которая вернет нам функция f2. Т.е. конечный результат создания контейнерной компоненты будет выглядеть вот так:</p>
    <img src="prim6.jpg" alt="">
    <p>Когда <b>connect</b> внутри себя вызовет эти две функции (f1 и f2) он передаст в качестве аргумента первой - state, а второй - dispatch</p>
    <p>Так как наша презентационная компонента ожидает в пропсах атрибут <b>state</b>, то функция f1 будет выглядеть уже вот так:</p>
    <img src="prim7.jpg" alt="">
    <p>Вторая функция должна создать объект с методами, эти методы будут переданы через пропс как колбеки. Вот как выглядит теперь функция f2</p>
    <img src="prim8.jpg" alt="">
    <p>Согласно документации первую функцию которая передает данные из state принято называть - <b>mapStateToProps</b>, вторую (та что передает callback) - <b>mapDispatchToProps</b></p>
    <p>Вот как в конечном результате выглядит наш код</p>
    <img src="prim9.jpg" alt="">
    <h2>Копия состояния</h2>
    <p>Подытожим что мы сделали. Мы создали контейнерную компоненту, которая пробрасывает через пропсы нужный участок state и две callback функции. Эти callback функции получают какое-то значение и передают в dispatch какой-то action, который создали с помощью функций (<strong>changeMessageText</strong> и <strong>AddMessageActionCreator</strong>). В Dispatch эти action попадают в reducer где по идее мы меняем state... НО!!! Принцип работы react-redax построент так, что он не имеет права изменять текущий объект. Это называется принцип чистой функции. Мы получаем данные и что-то возвращаем. НО!! мы не имеем право изменять то что нам дали. Чистая функция не изменяем те параметры которая она получила. Она создает копию входных данных изменяет их и затем их возвращает. В итоге мы видим то что отрисовка изменений не происходит.</p>
    <p>Первое что нам нужно сделать - это убрать функцию RenderDom. Т.е. файл index.js должен выглядеть вот так:</p>
    <img src="prim10.jpg" alt="">
    <p>Функция <b>connect</b> сама будет отрисовывать приложение в случае изменения в state. Как это работает? Каждый раз, когда был изменен state, происходит вызов функции mapStateToProps, т.е. формируется новый объект и этот новый объект сравнивается со старым (сравниваются внутренности объектов). Т.к. эти два объекта ссылаются на один и тот же объект, то JS считает их равными (см. сравнение объектов), а в случае если объекты равны <b>connect</b> не производит переррисовку приложения. Т.е. state по факту меняется, а перерисовка не происходит. Как быть?</p>
    <p>Для выхода из этой ситуации в reducer необходимо создавать копию state, вносить изменения именно в копию, и возвращать копию. Вот как теперь будет выглядеть reduser</p>
    <img src="prim11.jpg" alt="">
    <p>После этого <b>connect</b> будет сравнивать два объекта которые будут ссылаться на разные источники (state и stateCopy) будет видеть их разницу, следовательно - перерисовывать приложение.</p>
    <h2>Сокращение функции mapDispatchToProps</h2>
    <p>Если посмотреть на то как выглядит в данный момент функция <strong>mapDispatchToProps</strong></p>
    <img src="prim12.jpg" alt="">
    <p>то мы увидим что мы по сути повторяем один и тот же код. Мы получаем значение передаем его action creater и полученный результат диспатчим. Разработчики React-Redux создали возможность сокращения этого кода. Как это будет выглядеть? мы функции connect в первом вызове будем передавать не две функции (mapStateToProps и mapDispatchToProps), а  функцию (mapStateToProps) и объект. Как должен выглядеть наш объект:</p>
    <img src="prim13.jpg" alt="">
    <p>Т.е. ключ объекта это имя callBack функции которая прокинется в компоненты, а значение ключа это - actionCreator который мы создавали в reducer</p>
    <p>Но и этот код мы можем сократить. Если в reducer функции action creator мы назовем так же как и callBack то наш объект будет выглядеть уже вот так</p>
    <img src="prim14.jpg" alt="">
    <p>Ну и конечно же нам незачем создавать этот объект мы просто его передаем в connect</p>
    <img src="prim15.jpg" alt="">






</body>
</html>