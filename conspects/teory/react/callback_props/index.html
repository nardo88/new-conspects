<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <h1>Прокидывание callback через props</h1>
    <p>Рассмотрим схему:</p>
    <img style="width: 400px;" src="prim1.jpg" alt="">
    <p>У нас есть определенный state (как правило это массив значений, обычно объектов, которые описывают что-то. Например сообщение или комментарий)</p>
    <p>Как мы отрисовываем наш state? В качестве props мы прокидываем наш state в App.js? затем так же через props передаем его в компоненту, там мы данные мапим (map) и происходит отрисовка.</p>
    <p>Но как нам быть, если нужно в компоненте отредактировать наш state (например добавить сообщение или коммент)?</p>
    <p>Для этого нам нужно в файле где создается state создать функцию по изменению этого state и передать эту функцию через props до нашей компоненты. Эта функция должна принимать аргументы, которые будут передаваться в нашей компоненте. Т.е. эта функция будет вызываться в компоненте, но выполняться в том файле где была объявлена.</p>
    <p>Рассмотрим пример</p>
    <p>У нас есть state. Это Массив объектов с постами:</p>
    <img src="prim2.jpg" alt="">
    <p>Создадим функцию которая будет пушить в массив новый объект</p>
    <img src="prim3.jpg" alt="">
    <p>Импортируем эту функцию в файле index.js и передадим ее в каччестве props-а компоненте App.js</p>
    <img src="prim4.jpg" alt="">
    <p>После этого, так же через props передаем функцию в копмоненту</p>
    <img src="prim5.jpg" alt="">
    <p>В компоненте мы создаем функцию, которая будет вызываться по нажатии на кнопку добавить пост. Вот как выглядит эта функция:</p>
    <img src="prim6.jpg" alt="">
    <p>Здесь через props мы обращаемся к функции, вызываем ее и на вход даем значение элемента textarea который мы получили через ref. В массив занесено новое значение и state изменен, <span class="red">НО</span> изменения не отрисовались. Потому что функция React <b>render</b> была запущена один только раз при запуске приложения. Это значит что эту функцию нам нужно запускать каждый раз как был изменен state. т.е. эта функция должна запускаться в двух файлах <b>index.js</b> и <b>state.js</b></p>
    <p><span class="red">Вопрос</span> где должна быть создана эта функция. в файле index.js мы ее создать не можем так как в этом случае нам придется ее импортировать в state.js и тогда будет создана циклическая зависимость (из state мы импортируем в index состояние, а из index в state функцию render). Так делать категорически нельзя. Выход - создать отдельный файл в котором мы объявим функцию <b>renderDom</b> и эту функцию мы импортируем и в index и в state</p>
    <p>Мы копируем весь файл index.js и копию переименовываем в render.js</p>
    <p>Вот тело этого файла</p>
    <img src="prim7.jpg" alt="">
    <p>Теперь в файле <b>index.js</b> мы удаляем вызов React.render(), импортируем функцию <b>renderDom</b> и вызываем ее. Вот как теперь выглядит index.js</p>
    <img src="prim8.jpg" alt="">
    <p>Не збываем про то что функция renderDom должна получить в качестве аргумента state</p>
    <p>Теперь импортируем нашу функцию <b>renderDom</b> в файл state.js и так же вызываем ее задав на вход state (данные массива) после того как зарушили новые данные. Т.е. еще раз: мы сначала пушим новые данные в массив и затем отрисовываем приложение заново!</p>
    <img src="prim9.jpg" alt="">


    <h2>CallBack через props с использованием ООП</h2>
    <p>Теперь рассмотрим эту же задачу, но уже со state который создан через объект с методами (с ипользованием принципов ООП). Т.е. в файле state.js кроме объекта ничего нет, функция изменения state представлена как метод объекта <b>store</b>. Вот как выглядит теперь файл state.js</p>
    <img src="prim10.jpg" alt="">
    <p>На что мы здесь обращаем внимание? Отметим что все функции у нас обращаются к свойствам объекта store через контекст вызова <b>this</b>. Отмечаем это в голове.</p>
    <p>Теперь рассмотрим как все стало выглядеть в файле index.js</p>
    <img src="prim11.jpg" alt="">
    <p>Что здесь изменилось? Во-первых, теперь мы везде обращаемся к объекту <b>score</b>. Но больший интерес у нас вызывает вызов компоненты <b>App</b>, то, как мы передаем пропсы, а именно, callback функции. Раньше мы просто передавали функцию не вызывая ее. Теперь, так как мы передаем callback, который является методом объекта (а там, мы поним, что метод использует контекст вызова this), то нам обязательно надо метод забайндить (применить метод bind). Зачем? Посмотрим как этот же метод вызывается в файле <b>List.jsx</b> (это то место куда callback в итоге попадают)</p>
    <img src="prim12.jpg" alt="">
    <p>На что в этом случае ссылается контекстное слово this? в этом случае оно ссылается не на объект store и на объект props. В результате мы получаем ошибку:</p>
    <img src="prim13.jpg" alt="">
    <p>Что бы такого не случалось нам надо передать забайнденный метод и на вход методу bind мы передаем имя объекта store.</p>

</body>
</html>