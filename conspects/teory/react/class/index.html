<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../../../../css/conspects.css">
</head>
<body>
    <h1>Классовый компонент</h1>
    <p>Пример написания классовой компонениы</p>
    <img src="./img1.jpg" alt="">
    <h2>Инициализация компонента (constructor)</h2>
    <p>Если не указывать у компоненты конструктор, то этот конструктор будет унаследован от родительского класса React.Component.</p>
    <p>Что бы переопределить construcor мы просто обьявляем его как в обычных ES6 классах</p>
    <img src="./img2.jpg" alt="">
    <h2>Локальный state</h2>
    <p>Обьявление локального state лучше всего обьявлять в конструкторе, но и допустимо его объявлять и вне его.</p>
    <img src="./img3.jpg" alt="">
    <p>Изменение state происходит при помощи вызова метода setState</p>
    <img src="./img4.jpg" alt="">
    <p>Так же метод setState может получить в качестве значению функцию. Этой функции будет передан весь объект локального state. То что вернет эта функция будет записано в локальный state. Вторым аргументом функция получит объект с пропсами.</p>
    <img src="./img5.jpg" alt="">
    <h2>Потеря контекста</h2>
    <p>Так как при использовании методов классовой компоненты внутри JSX которые будут вызываться по какому-либо событию мы можем столкнуться с таким явлением как потеря контекста. Это связано с тем, что при срабатывании события this будет ссылаться не на класс, а на тот объект который вызвал событие (элемент DOM)</p>
    <p>Что бы избежать потерятю контекста мы можем либо использовать струлочные функции, либо использовать методы по передаче контекста (bind). Биндить методы следует внутри конструктора.</p>
    <img src="./img6.jpg" alt="">
    <p>Решение той же проблемы, но уже с помощью стрелочной функции</p>
    <img src="./img7.jpg" alt="">
    <h2>Методы жизненного цикла</h2>
    <p>Существует три основные стадии жизненного цикла классовой компоненты:</p>
    <ol >
        <li><b>Монтирование</b></li>
        <li><b>Обнолвение</b></li>
        <li><b>Демонтирование</b></li>
    </ol>
    <h3>componentWillMount</h3>
    <p>Этот метод будет вызван до рендера компонента. В этом методе лучше всего совершать ассинхронные операции, обращения к API и т.д.</p>
    <img src="./img8.jpg" alt="">
    <h3>componentWillMount</h3>
    <p>Этот метод будет выполнен сразу после монтирования компонента (после рендера)</p>
    <img src="./img9.jpg" alt="">
    <h3>componentWillUnmount</h3>
    <p>Этот метод будет вызван перед демонтированием компонента</p>
    <img src="./img10.jpg" alt="">
    <h2>Методы жизненного цикла при обновлении</h2>
    <p>Методы обнолвения вызываются каждый раз при обновлении локального state классовой компоненты. Вызов метода setState внутри метода жизненого цикла обновления вызовет бесконечный перерендер.</p>
    <p>Основные методы</p>
    <p><b>shouldComponentUpdate(nextProps, nextState)</b> - этот метод способен отменить обновление компоненты, если этот метод вернет значение false. В качестве аргументов принимает новые пропсы и новый state. Можно сравнить эти значения со старыми и тем самым определить, надо ли нам обновлять компоненту. Если метод вернет false то обновление не произойдет</p>
    <img src="./img11.jpg" alt="">
    <p><b>componentWillUpdate(nextProps, nextState)</b> - метод вызывается перед обновлпением компоненты. В качестве аргументов получает новые пропсы и новый state</p>
    <img src="./img12.jpg" alt="">
    <p><b>componentDidUpdate(prevProps, prevState)</b> - метод будет запущен после обновления компонента. В качестве аргументов будут переданы сратые версии пропсов и state которые были до обновления.</p>

    <script>

        import React from 'react'

        class SomeComponent extends React.Component{
            constructor(props){
                super(props)
                this.state = {
                    value: ''
                }
            }

            changeValue = (e) => {
                this.setState((state, props) => {
                    return {...state, value: e. target.value}
                })
            }

            render(){
                return(
                    <div>
                        <input value={this.state.value} onChange={this.changeValue}/>
                    </div>
                )
            }
        }

        SomeComponent.propTypes = {

        }



    </script>

</body>
</html>